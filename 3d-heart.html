<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>点击纯白爱心爆发特效</title>
    <link rel="shortcut icon" href="http://zhouql.vip/images/心.png" type="image/x-icon">
    <style>
        /* 全局重置 */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* 视频背景（最底层） */
        #main {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        #video1 {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 粒子画布（最上层，确保特效在最前面） */
        canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 999;
            pointer-events: auto; /* 确保可接收点击事件 */
        }
    </style>
</head>
<body>

    <!-- 背景视频 -->
    <div id="main">
        <video id="video1" muted autoplay loop playsinline
               src="https://sns-video-hw.xhscdn.com/01e37340b5183ab501037003847a34f7ad_258.mp4?sign=e0e7bafd11769da1d62739ec9a086f13&t=66180900">
        </video>
    </div>

    <!-- 粒子特效画布（最上层） -->
    <canvas id="heartCanvas"></canvas>

    <script>
        // ==================== 可配置参数 ====================
        const CONFIG = {
            particles: {
                maxCount: 800,        // 粒子池最大数量
                burstCount: 80,       // 每次点击爆发的粒子数
                duration: 1.8,        // 粒子生命周期（秒）
                velocity: 120,        // 初始速度
                size: 30              // 爱心大小（px）
            },
            heartColor: '#ffffff',    // 爱心颜色（纯白），可改：#ff6b6b、#ffd700 等
            effect: -0.75             // 扩散加速度（负值向外）
        };

        // ==================== requestAnimationFrame 兼容 ====================
        (function() {
            const vendors = ['ms', 'moz', 'webkit', 'o'];
            for (let i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
                window.requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
                window.cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
            }
            if (!window.requestAnimationFrame) {
                let lastTime = 0;
                window.requestAnimationFrame = function(callback) {
                    const now = Date.now();
                    const nextTime = Math.max(lastTime + 16, now);
                    return setTimeout(() => callback(lastTime = nextTime), nextTime - now);
                };
                window.cancelAnimationFrame = clearTimeout;
            }
        })();

        // ==================== 向量类 ====================
        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            clone() { return new Vec2(this.x, this.y); }
            len() { return Math.hypot(this.x, this.y); }
            normalize() {
                const len = this.len();
                if (len > 0) { this.x /= len; this.y /= len; }
                return this;
            }
            scale(s) { this.x *= s; this.y *= s; return this; }
        }

        // ==================== 粒子类 ====================
        class Particle {
            constructor() { this.reset(); }
            reset() {
                this.pos = new Vec2();
                this.vel = new Vec2();
                this.age = 0;
                this.active = false;
            }
            init(x, y, vx, vy) {
                this.pos.x = x; this.pos.y = y;
                this.vel.x = vx; this.vel.y = vy;
                this.age = 0;
                this.active = true;
            }
            update(dt) {
                if (!this.active) return;
                this.pos.x += this.vel.x * dt;
                this.pos.y += this.vel.y * dt;
                this.vel.x += this.vel.x * CONFIG.effect * dt;
                this.vel.y += this.vel.y * CONFIG.effect * dt;
                this.age += dt;
                if (this.age >= CONFIG.particles.duration) this.active = false;
            }
            draw(ctx, img) {
                if (!this.active) return;
                const t = this.age / CONFIG.particles.duration;
                const ease = 1 - (1 - t) ** 3; // easeOutCubic
                const size = img.width * ease;
                ctx.globalAlpha = 1 - t;
                ctx.drawImage(img, this.pos.x - size/2, this.pos.y - size/2, size, size);
            }
        }

        // ==================== 高效粒子池（环形缓冲）===================
        class ParticlePool {
            constructor() {
                this.particles = Array(CONFIG.particles.maxCount).fill().map(() => new Particle());
                this.head = 0;
            }
            alloc(x, y, vx, vy) {
                const p = this.particles[this.head];
                p.init(x, y, vx, vy);
                this.head = (this.head + 1) % this.particles.length;
            }
            update(dt) {
                for (const p of this.particles) {
                    if (p.active) p.update(dt);
                }
            }
            draw(ctx, img) {
                for (const p of this.particles) {
                    if (p.active) p.draw(ctx, img);
                }
            }
        }

        // ==================== 创建爱心图像（支持颜色配置） ====================
        const createHeartImage = (size, color) => {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const to = t => {
                const p = new Vec2(
                    160 * Math.pow(Math.sin(t), 3),
                    130 * Math.cos(t) - 50 * Math.cos(2*t) - 20 * Math.cos(3*t) - 10 * Math.cos(4*t) + 25
                );
                return new Vec2(
                    size/2 + p.x * size/350,
                    size/2 - p.y * size/350
                );
            };

            ctx.beginPath();
            let t = -Math.PI;
            let pt = to(t);
            ctx.moveTo(pt.x, pt.y);
            while (t < Math.PI) {
                t += 0.01;
                pt = to(t);
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            const img = new Image();
            img.src = canvas.toDataURL();
            return img;
        };

        // ==================== 主逻辑 ====================
        (function() {
            const canvas = document.getElementById('heartCanvas');
            const ctx = canvas.getContext('2d');
            const pool = new ParticlePool();

            // 创建纯白爱心图像（可通过 CONFIG.heartColor 修改）
            const heartImg = createHeartImage(CONFIG.particles.size, CONFIG.heartColor);

            // 预计算 360 度方向向量（均匀分布）
            const directions = [];
            for (let i = 0; i < 360; i += 3) {
                const rad = i * Math.PI / 180;
                directions.push(new Vec2(Math.cos(rad), Math.sin(rad)));
            }

            // 画布尺寸自适应
            const resize = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };
            resize();
            window.addEventListener('resize', resize);

            // 爆发特效
            const burst = (x, y) => {
                const count = CONFIG.particles.burstCount;
                for (let i = 0; i < count; i++) {
                    const baseDir = directions[i % directions.length];
                    const dir = baseDir.clone().normalize().scale(CONFIG.particles.velocity);
                    // 添加随机扰动，更自然
                    dir.x += (Math.random() - 0.5) * 60;
                    dir.y += (Math.random() - 0.5) * 60;
                    pool.alloc(x, y, dir.x, dir.y);
                }
            };

            // 点击 & 触摸事件（支持多点）
            const handleInteraction = e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                burst(clientX - rect.left, clientY - rect.top);
            };

            canvas.addEventListener('click', handleInteraction);
            canvas.addEventListener('touchstart', handleInteraction, { passive: false });

            // 渲染循环
            let lastTime = 0;
            const render = now => {
                if (!lastTime) lastTime = now;
                const dt = Math.min((now - lastTime) / 1000, 0.1);
                lastTime = now;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pool.update(dt);
                pool.draw(ctx, heartImg);

                requestAnimationFrame(render);
            };

            // 图像加载完成后再启动
            heartImg.onload = () => {
                setTimeout(() => requestAnimationFrame(render), 100);
            };
        })();
    </script>
</body>
</html>
