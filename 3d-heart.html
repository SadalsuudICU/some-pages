<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>点击渐变爱心尾迹特效（手机兼容）</title>
    <link rel="shortcut icon" href="http://zhouql.vip/images/心.png" type="image/x-icon">
    <style>
        *, *::before, *::after { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }

        #main {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        #video1 {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* 强制触发硬件加速 */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        #heartCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 999;
            pointer-events: auto;
            background: transparent;
        }
    </style>
</head>
<body>

    <div id="main">
        <video id="video1" 
               muted 
               autoplay 
               loop 
               playsinline 
               webkit-playsinline 
               x5-playsinline 
               preload="auto"
               crossorigin="anonymous">
            <source src="./love-bg.mp4" type="video/mp4">
            您的浏览器不支持视频。
        </video>
    </div>

    <canvas id="heartCanvas"></canvas>

    <script>
        // ==================== 手机视频兼容修复 ====================
        const video = document.getElementById('video1');
        let videoStarted = false;

        function tryPlayVideo() {
            if (videoStarted) return;
            const playPromise = video.play();
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        videoStarted = true;
                        console.log('视频自动播放成功');
                    })
                    .catch(err => {
                        console.warn('自动播放失败，等待用户交互', err);
                        // 等待第一次点击后播放
                        const startVideo = () => {
                            video.play().then(() => {
                                videoStarted = true;
                                console.log('用户交互后视频播放成功');
                            });
                            document.removeEventListener('touchstart', startVideo);
                            document.removeEventListener('click', startVideo);
                        };
                        document.addEventListener('touchstart', startVideo, { once: true });
                        document.addEventListener('click', startVideo, { once: true });
                    });
            }
        }

        // 页面加载后尝试播放
        if (document.readyState === 'complete') {
            tryPlayVideo();
        } else {
            window.addEventListener('load', tryPlayVideo);
        }

        // ==================== Canvas 初始化 ====================
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            console.log('Canvas:', canvas.width, 'x', canvas.height);
        }
        initCanvas();
        window.addEventListener('resize', initCanvas);

        // ==================== 配置 ====================
        const CONFIG = {
            particles: {
                maxCount: 1000,
                burstCount: 100,
                duration: 2.2,
                velocity: 100,
                size: 28
            },
            heartGradient: ['#ff6b6b', '#ffd93d', '#6bcf7f', '#4d96ff', '#ff6b9d'],
            effect: -0.6
        };

        // ==================== requestAnimationFrame ====================
        (function() {
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = cb => setTimeout(cb, 16);
            }
        })();

        // ==================== 向量 & 粒子系统（同前）===================
        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            clone() { return new Vec2(this.x, this.y); }
            len() { return Math.hypot(this.x, this.y); }
            normalize() { const l = this.len(); if (l > 0) { this.x /= l; this.y /= l; } return this; }
            scale(s) { this.x *= s; this.y *= s; return this; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
        }

        class Particle {
            constructor() { this.reset(); this.trail = []; this.maxTrail = 10; }
            reset() { this.pos = new Vec2(); this.vel = new Vec2(); this.age = 0; this.active = false; this.trail = []; }
            init(x, y, vx, vy) { this.pos.x = x; this.pos.y = y; this.vel.x = vx; this.vel.y = vy; this.age = 0; this.active = true; this.trail = []; }
            update(dt) {
                if (!this.active) return;
                this.pos.x += this.vel.x * dt;
                this.pos.y += this.vel.y * dt;
                this.vel.x += this.vel.x * CONFIG.effect * dt;
                this.vel.y += this.vel.y * CONFIG.effect * dt;
                this.age += dt;
                this.trail.push(this.pos.clone());
                if (this.trail.length > this.maxTrail) this.trail.shift();
                if (this.age >= CONFIG.particles.duration) this.active = false;
            }
            draw(ctx, heartCanvas) {
                if (!this.active) return;
                const t = this.age / CONFIG.particles.duration;
                const ease = 1 - Math.pow(1 - t, 3);
                const size = heartCanvas.width * ease * 0.8;

                for (let i = 0; i < this.trail.length; i++) {
                    const trailT = t - i / this.maxTrail;
                    if (trailT < 0) continue;
                    const alpha = (1 - trailT) * 0.3;
                    const s = size * (i / this.maxTrail) * 0.3;
                    ctx.globalAlpha = alpha;
                    ctx.drawImage(heartCanvas, this.trail[i].x - s/2, this.trail[i].y - s/2, s, s);
                }

                ctx.globalAlpha = (1 - t) * 0.8;
                ctx.drawImage(heartCanvas, this.pos.x - size/2, this.pos.y - size/2, size, size);
            }
        }

        class ParticlePool {
            constructor() {
                this.particles = Array.from({ length: CONFIG.particles.maxCount }, () => new Particle());
                this.head = 0;
                this.activeCount = 0;
            }
            alloc(x, y, vx, vy) {
                if (this.activeCount >= CONFIG.particles.maxCount) return;
                const p = this.particles[this.head];
                if (p.active) { this.head = (this.head + 1) % this.particles.length; return; }
                p.init(x, y, vx, vy);
                this.head = (this.head + 1) % this.particles.length;
                this.activeCount++;
            }
            update(dt) {
                let off = 0;
                for (const p of this.particles) {
                    if (p.active) { p.update(dt); if (!p.active) off++; }
                }
                this.activeCount -= off;
            }
            draw(ctx, img) { for (const p of this.particles) if (p.active) p.draw(ctx, img); }
        }

        const createHeartImage = (size, colors) => {
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const x = c.getContext('2d');
            const g = x.createRadialGradient(size/2, size/2-5, 0, size/2, size/2, size/2);
            colors.forEach((col, i) => g.addColorStop(i/(colors.length-1), col));

            const to = t => {
                const p = new Vec2(160*Math.pow(Math.sin(t),3), 130*Math.cos(t)-50*Math.cos(2*t)-20*Math.cos(3*t)-10*Math.cos(4*t)+25);
                return new Vec2(size/2 + p.x*size/350, size/2 - p.y*size/350);
            };

            x.beginPath();
            let t = -Math.PI, pt = to(t);
            x.moveTo(pt.x, pt.y);
            while (t < Math.PI) { t += 0.013; pt = to(t); x.lineTo(pt.x, pt.y); }
            x.closePath();
            x.fillStyle = g;
            x.fill();
            x.shadowColor = colors[colors.length-1];
            x.shadowBlur = 8;
            x.fill();
            x.shadowBlur = 0;
            return c;
        };

        // ==================== 主程序 ====================
        (function() {
            const pool = new ParticlePool();
            const heartImg = createHeartImage(CONFIG.particles.size, CONFIG.heartGradient);
            const dirs = [];
            for (let i = 0; i < 360; i += 2) dirs.push(new Vec2(Math.cos(i*Math.PI/180), Math.sin(i*Math.PI/180)));

            let lastBurst = 0;
            const burst = (x, y) => {
                const now = Date.now();
                if (now - lastBurst < 50) return;
                lastBurst = now;
                for (let i = 0; i < CONFIG.particles.burstCount; i++) {
                    const d = dirs[(i*137.5)%dirs.length|0].clone().scale(CONFIG.particles.velocity);
                    d.add(new Vec2((Math.random()-0.5)*80, (Math.random()-0.5)*80));
                    pool.alloc(x, y, d.x, d.y);
                }
                // 第一次点击后确保视频播放
                if (!videoStarted) tryPlayVideo();
            };

            canvas.onclick = canvas.ontouchstart = e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX || e.touches[0].clientX) - rect.left;
                const y = (e.clientY || e.touches[0].clientY) - rect.top;
                burst(x, y);
            };

            let lastTime = 0;
            const render = now => {
                if (!lastTime) lastTime = now;
                const dt = Math.min((now - lastTime)/1000, 0.1);
                lastTime = now;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pool.update(dt);
                pool.draw(ctx, heartImg);

                requestAnimationFrame(render);
            };

            requestAnimationFrame(render);
            console.log('特效已就绪');
        })();
    </script>
</body>
</html>
