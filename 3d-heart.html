<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>渐变爱心尾迹特效（本地视频）</title>
    <link rel="shortcut icon" href="http://zhouql.vip/images/心.png" type="image/x-icon">
    <style>
        /* 全局重置 */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* 视频背景（最底层） */
        #main {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        #video1 {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 粒子画布（最上层） */
        canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 999;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <!-- 背景视频（使用本地文件） -->
    <div id="main">
        <video id="video1" muted autoplay loop playsinline>
            <source src="./love-bg.mp4" type="video/mp4">
            您的浏览器不支持视频播放。
        </video>
    </div>

    <!-- 粒子特效画布 -->
    <canvas id="heartCanvas"></canvas>

    <script>
        // ==================== 可配置参数 ====================
        const CONFIG = {
            particles: {
                maxCount: 1000,
                burstCount: 100,
                duration: 2.2,
                velocity: 100,
                size: 28
            },
            heartGradient: ['#ff6b6b', '#ffd93d', '#6bcf7f', '#4d96ff', '#ff6b9d'],
            effect: -0.6
        };

        // ==================== requestAnimationFrame 兼容 ====================
        (function() {
            if (!window.requestAnimationFrame) {
                const vendors = ['ms', 'moz', 'webkit', 'o'];
                for (let i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
                    window.requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
                }
                if (!window.requestAnimationFrame) {
                    let lastTime = 0;
                    window.requestAnimationFrame = function(callback) {
                        const now = Date.now();
                        const nextTime = Math.max(lastTime + 16, now);
                        return setTimeout(() => callback(lastTime = nextTime), nextTime - now);
                    };
                    window.cancelAnimationFrame = clearTimeout;
                }
            }
        })();

        // ==================== 向量类 ====================
        class Vec2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            clone() { return new Vec2(this.x, this.y); }
            len() { return Math.hypot(this.x, this.y); }
            normalize() {
                const l = this.len();
                if (l > 0) { this.x /= l; this.y /= l; }
                return this;
            }
            scale(s) { this.x *= s; this.y *= s; return this; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
        }

        // ==================== 粒子类（带尾迹） ====================
        class Particle {
            constructor() {
                this.reset();
                this.trail = [];
                this.maxTrail = 10;
            }
            reset() {
                this.pos = new Vec2();
                this.vel = new Vec2();
                this.age = 0;
                this.active = false;
                this.trail = [];
            }
            init(x, y, vx, vy) {
                this.pos.x = x;
                this.pos.y = y;
                this.vel.x = vx;
                this.vel.y = vy;
                this.age = 0;
                this.active = true;
                this.trail = [];
            }
            update(dt) {
                if (!this.active) return;
                this.pos.x += this.vel.x * dt;
                this.pos.y += this.vel.y * dt;
                this.vel.x += this.vel.x * CONFIG.effect * dt;
                this.vel.y += this.vel.y * CONFIG.effect * dt;
                this.age += dt;

                this.trail.push(this.pos.clone());
                if (this.trail.length > this.maxTrail) this.trail.shift();

                if (this.age >= CONFIG.particles.duration) this.active = false;
            }
            draw(ctx, heartCanvas) {
                if (!this.active) return;
                const t = this.age / CONFIG.particles.duration;
                const ease = 1 - Math.pow(1 - t, 3);
                const size = heartCanvas.width * ease * 0.8;

                // 尾迹
                for (let i = 0; i < this.trail.length; i++) {
                    const trailAge = t - (i / this.maxTrail);
                    if (trailAge < 0) continue;
                    const trailAlpha = (1 - trailAge) * 0.3;
                    const trailSize = size * (i / this.maxTrail) * 0.3;
                    ctx.save();
                    ctx.globalAlpha = trailAlpha;
                    ctx.drawImage(heartCanvas, this.trail[i].x - trailSize / 2, this.trail[i].y - trailSize / 2, trailSize, trailSize);
                    ctx.restore();
                }

                // 当前爱心
                ctx.save();
                ctx.globalAlpha = (1 - t) * 0.8;
                ctx.drawImage(heartCanvas, this.pos.x - size / 2, this.pos.y - size / 2, size, size);
                ctx.restore();
            }
        }

        // ==================== 粒子池 ====================
        class ParticlePool {
            constructor() {
                this.particles = Array.from({ length: CONFIG.particles.maxCount }, () => new Particle());
                this.head = 0;
                this.activeCount = 0;
            }
            alloc(x, y, vx, vy) {
                if (this.activeCount >= CONFIG.particles.maxCount) return;
                const p = this.particles[this.head];
                if (p.active) return;
                p.init(x, y, vx, vy);
                this.head = (this.head + 1) % this.particles.length;
                this.activeCount++;
            }
            update(dt) {
                let deactivated = 0;
                for (const p of this.particles) {
                    if (p.active) {
                        p.update(dt);
                        if (!p.active) deactivated++;
                    }
                }
                this.activeCount -= deactivated;
            }
            draw(ctx, heartCanvas) {
                for (const p of this.particles) {
                    if (p.active) p.draw(ctx, heartCanvas);
                }
            }
        }

        // ==================== 创建渐变爱心 ====================
        const createHeartImage = (size, colors) => {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(size / 2, size / 2 - 5, 0, size / 2, size / 2, size / 2);
            colors.forEach((color, i) => {
                gradient.addColorStop(i / (colors.length - 1), color);
            });

            const to = t => {
                const p = new Vec2(
                    160 * Math.pow(Math.sin(t), 3),
                    130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
                );
                return new Vec2(
                    size / 2 + p.x * size / 350,
                    size / 2 - p.y * size / 350
                );
            };

            ctx.beginPath();
            let t = -Math.PI;
            let pt = to(t);
            ctx.moveTo(pt.x, pt.y);
            while (
